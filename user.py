import re
import bcrypt
import random
import string

import admin
from db import db
import session
from online import online

class BaseUser:
        def __init__(self):
                self.is_online = False

        def log_in(self, conn):
                self.session = conn.session
                self.session.set_user(self)
                online.add(self)
                self.is_online = True

        def log_out(self):
                if not self.is_guest:
                        db.user_update_last_logout(self.id)
                self.is_online = False
                online.remove(self)

        def write(self, s):
                assert(self.is_online)
                self.session.conn.write(s)
        
        def get_display_name(self):
                if self.is_guest:
                        return self.name + '(U)'
                else:
                        return self.name

# a registered user
class User(BaseUser):
	def __init__(self, u):
                #super(User, self).__init__()
                BaseUser.__init__(self)
                self.id = u['user_id']
                self.name = u['user_name']
                self.passwd_hash = u['user_passwd']
                self.last_logout = u['user_last_logout']
                self.is_guest = False

        def set_passwd(self, passwd):
                self.passwd_hash = bcrypt.hashpw(passwd, bcrypt.gensalt())
                db.user_set_passwd(self.id, self.passwd_hash)

        def set_admin_level(self, level):
                db.user_set_admin_level(self.id, level)
        
        # check if an unencrypted password is correct
        def check_passwd(self, passwd):
                # don't perform expensive computation on arbitrarily long data
                if not is_legal_passwd(passwd):
                        return False
                return bcrypt.hashpw(passwd, self.passwd_hash) == self.passwd_hash
        
        def get_last_logout(self):
                return db.user_get_last_logout(self.id)

class GuestUser(BaseUser):
        def __init__(self, name):
                #super(GuestUser, self).__init__()
                BaseUser.__init__(self)
                self.is_guest = True
                if name == None:
                        count = 0
                        while True:
                                self.name = 'Guest'
                                for i in range(4):
                                        self.name = self.name + random.choice(string.ascii_uppercase)
                                if not session.online.is_online(self.name):
                                        break
                                count = count + 1
                                if count > 3:
                                        raise UsernameException(_('Unable to create a guest account!'))
                                
                        self.autogenerated_name = True
                else:
                        self.name = name
                        self.autogenerated_name = False

class UsernameException(Exception):
        def __init__(self, reason):
                self.reason = reason

class AmbiguousException(Exception):
        def __init__(self, names):
                self.names = names

class Find:
        # return a user object if one exists; otherwise make a 
        # guest user
        def by_name_for_login(self, name, conn):
                if name.lower() == 'g' or name.lower() == 'guest':
                        u = GuestUser(None)
                        conn.write(_('\nLogging you in as "%s"; you may use this name to play unrated games.\n(After logging in, do "help register" for more info on how to register.)\n\nPress return to enter as "%s":') % (u.name, u.name))
                else:
                        u = self.by_name_exact(name)
                        if u:
                                if u.is_guest:
                                        # It's theoretically possible that
                                        # a new user registers but is blocked
                                        # from logging in by a guest with the
                                        # same name.  We ignore that case.
                                        raise UsernameException(_('Sorry, %s is already logged in. Try again.\n') % name)
                                else:
                                        conn.write(_('\n%s is a registered name.  If it is yours, type the password.\nIf not, just hit return to try another name.\n\npassword: ') % name)
                        else:
                                u = GuestUser(name)
                                conn.write(_('\n"%s" is not a registered name.  You may play unrated games as a guest.\n(After logging in, do "help register" for more info on how to register.)\n\nPress return to enter as "%s":') % (name, name))
                return u

        def by_name_exact(self, name, min_len = 3):
                if len(name) < min_len:
                        raise UsernameException(_('A name should be at least %d characters long!  Try again.\n') % 3)
                elif len(name) > 18:
                        raise UsernameException(_('Sorry, names may be at most %d characters long.  Try again.\n') % 18)
                elif not re.match('^[a-zA-Z_]+$', name):
                        raise UsernameException(_('Sorry, names can only consist of lower and upper case letters.  Try again.\n'))

                u = session.online.find_exact(name)
                if not u:
                        dbu = db.get_user(name)
                        if dbu:
                                u = User(dbu)
                return u

        """ find a user but allow the name to abbreviated if
        it is unambiguous; if the name is not an exact match, prefer
        online users to offline """
        def by_name_or_prefix(self, name):
                assert(len(name) >= 2)
                u = self.by_name_exact(name, 2)
                if not u:
                        ulist = session.online.find_matching(name)
                        if len(ulist) == 1:
                                u = ulist[0]
                        elif len(ulist) > 1:
                                # when there are multiple matching users
                                # online, don't bother searching for offline
                                # users who also match
                                raise AmbiguousException([u.name for u in ulist])
                if not u: 
                        ulist = db.user_get_matching(name)
                        if len(ulist) == 1:
                                u = User(ulist[0])
                        elif len(ulist) > 1:
                                raise AmbiguousException([u['user_name'] for u in ulist])
                return u

find = Find()
        
# test whether a string meets the requirements for a password
def is_legal_passwd(passwd):
        if len(passwd) > 32:
                return False
        if len(passwd) < 4:
                return False
        # passwords may not contain spaces because they are set
        # using a command
        if not re.match(r'^\S+$', passwd):
                return False
        return True

class Create:
        def passwd(self):
                chars = string.letters + string.digits
                passlen = random.choice(range(5, 8))
                ret = ''
                for i in range(passlen):
                        ret = ret + random.choice(chars)
                return ret

        def new(self, name, email, passwd, real_name):
                hash = bcrypt.hashpw(passwd, bcrypt.gensalt())
                db.user_add(name, email, hash, real_name, admin.Level.user)
create = Create()

# vim: expandtab tabstop=8 softtabstop=8 shiftwidth=8 smarttab autoindent ft=python
